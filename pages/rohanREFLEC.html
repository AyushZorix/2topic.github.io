<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms and Data Structures</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            color: #333;
        }
        header {
            background: #007acc;
            color: white;
            padding: 1em 0;
            text-align: center;
        }
        section {
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            background: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #007acc;
        }
    </style>
</head>
<body>
    <header>
        <h1>Algorithms and Data Structures</h1>
    </header>

    <section>
        <h2>1. Problems in Nature</h2>
        <ul>
            <li><strong>Iteration:</strong> Spider web patterns, social media feeds, bee hive construction.</li>
            <li><strong>Recursion:</strong> Patterns in flower petals, sea shells, and food chains.</li>
            <li><strong>Backtracking:</strong> Beaver dam construction, solving puzzles like crosswords or Sudoku.</li>
        </ul>
    </section>

    <section>
        <h2>2. Time and Space Efficiency</h2>
        <p><strong>Time Efficiency:</strong> Measures execution time as input size grows.</p>
        <p><strong>Space Efficiency:</strong> Evaluates memory usage during processing.</p>
        <p>Importance: Faster algorithms enhance performance; space-efficient designs are essential for memory-constrained environments.</p>
        <ul>
            <li>Classes of Problems: O(1), O(log n), O(n), O(n²), O(2ⁿ).</li>
            <li>Orders of Growth: Best case, average case, worst case.</li>
        </ul>
    </section>

    <section>
        <h2>3. Sorting Algorithms</h2>
        <ul>
            <li>Bubble Sort: Simple but inefficient (O(n²)).</li>
            <li>Merge Sort: Efficient for large datasets (O(n log n)).</li>
            <li>Quick Sort: Fast average-case sorting (O(n log n)).</li>
            <li>Heap Sort: Priority-based sorting (O(n log n)).</li>
        </ul>
    </section>

    <section>
        <h2>4. Graph Algorithms</h2>
        <ul>
            <li>Kruskal’s Algorithm: Creates minimum spanning trees.</li>
            <li>Dijkstra’s Algorithm: Finds shortest paths in weighted graphs.</li>
            <li>Floyd-Warshall Algorithm: Computes all-pairs shortest paths.</li>
            <li>Prim’s Algorithm: Incremental spanning tree construction.</li>
        </ul>
        <p>Applications: Used in network design, logistics, and transportation optimization.</p>
    </section>

    <section>
        <h2>5. Hierarchical Data Representation</h2>
        <ul>
            <li>Binary Search Tree (BST): Efficient searching and updates.</li>
            <li>AVL Tree: Balanced structure for predictable performance.</li>
            <li>Trie: Supports fast prefix-based searches.</li>
            <li>Heap: Efficient for priority management.</li>
        </ul>
    </section>

    <section>
        <h2>6. Array Query Algorithms</h2>
        <ul>
            <li>Prefix Sums: Quick range queries.</li>
            <li>Segment Trees: Efficient range operations.</li>
            <li>Fenwick Trees: Fast cumulative frequency updates.</li>
        </ul>
        <p>Applications: Gaming leaderboards, data analytics, real-time systems.</p>
    </section>

    <section>
        <h2>7. Difference Between Tree and Graph</h2>
        <ul>
            <li>Tree: Hierarchical with no cycles (used in file systems).</li>
            <li>Graph: General structure with nodes and edges (used in networks).</li>
        </ul>
        <p>Traversals:</p>
        <ul>
            <li>Tree: Inorder, Preorder, Postorder.</li>
            <li>Graph: DFS, BFS.</li>
        </ul>
    </section>

    <section>
        <h2>8. Spanning Trees and Shortest Paths</h2>
        <ul>
            <li>Spanning Trees: Minimal connectivity for networks (Kruskal's, Prim's).</li>
            <li>Shortest Paths: Optimization in navigation (Dijkstra’s, A*).</li>
        </ul>
    </section>

    <section>
        <h2>9. Algorithm Design Techniques</h2>
        <ul>
            <li>Brute Force: Tries all solutions.</li>
            <li>Divide and Conquer: Recursively solves subproblems (e.g., Merge Sort).</li>
            <li>Dynamic Programming: Avoids redundant work (e.g., Fibonacci).</li>
            <li>Greedy Algorithms: Local optimization for global results (e.g., Kruskal’s).</li>
        </ul>
    </section>

    <footer style="text-align:center; padding:20px; background:#007acc; color:white;">
        
    </footer>
</body>
</html>

